#!/usr/bin/env python3

import sys
from math import *
import numpy as np
import time

import rospy
import actionlib
from actionlib_msgs.msg import GoalStatus
from geometry_msgs.msg import Point, PoseStamped
from nav_msgs.msg import Path
from spar_msgs.msg import FlightMotionAction, FlightMotionGoal, ArucoLocalisation
from breadcrumb.srv import RequestPath, RequestPathRequest
from sensor_msgs.msg import BatteryState
from std_msgs.msg import Bool
from std_msgs.msg import Int32

# This is getting a bit more complicated now, so we'll put our information in
# a class to keep track of all of our variables. This is not so much different
# to the previous methods, other than the fact that the class will operate
# within itself.
# i.e. it will have it's own publishers, subscribers, etc., that
# will call it's own functions as callbacks, etc.
global flight_height
flight_height = 2.2

class Guidance():
	def __init__(self, waypoints):
		# Make sure we have a valid waypoint list
		if not self.check_waypoints(waypoints):
			print("Invalid waypoint list input!, reccommend abort")

		# initialise battery percentage (for testing)
		self.battery_per = 1.0

		# Aruco Variables
		self.desired_aruco_id = 0 # Changed to the aruco marker to land
		self.current_aruco_id = -1
		self.previous_aruco_id = -1
		self.FoundAruco = False # If aruco is not found, land at origin (aruco landing contigency)

		# Camera Variables
		self.camera_FOV_x = 54 * (pi / 180) # [rad]
		self.camera_FOV_y = 66 * (pi / 180) # [rad]

		# Internal counter to see what waypoint were are up to
		self.waypoint_counter = 0
		self.reached_wp_1 = False # roi flag for target 1?

		# Set a flag to indicate that we are doing a specific inspection
		# and that we are not following our waypoint list
		# This will stop our "waypoint is reached" callback from firing
		# during the roi diversion and taking over our flight!
		self.performing_roi = False

		# Landing initialisation flag (to only run aruco_land once)
		self.aruco_land_initialised = False

		# Landing initialisation flag (critical battery)
		self.crit_bat_land_init = False

		# finished mission flag (to stop check_waypoint() running after aruco_land())
		self.mission_completed = False

		# initialise bread crumb (wait for service to be published)
		# srvc_bc is the service proxy object, once initialised can use to call a service like a function
		rospy.wait_for_service('/breadcrumb/request_path')
		self.srvc_bc = rospy.ServiceProxy('/breadcrumb/request_path',RequestPath)

		# Save the input waypoints
		self.waypoints = waypoints

		# Make some space to record down our current location
		self.current_location = Point()

		# Set our linear and rotational velocities for the flight
		self.vel_linear = rospy.get_param("~vel_linear",0.6) # edit speed here
		self.vel_yaw = rospy.get_param("~vel_yaw", 0.2)

		# Set our position and yaw waypoint accuracies
		self.accuracy_pos = rospy.get_param("~acc_pos", 0.2) # edit acc_pos here 
		self.accuracy_yaw = rospy.get_param("~acc_yaw", 0.1)

		# Create our action client
		action_ns = rospy.get_param("~action_topic", 'spar/flight')
		self.spar_client = actionlib.SimpleActionClient(action_ns, FlightMotionAction)
		rospy.loginfo("Waiting for spar...")
		self.spar_client.wait_for_server()

		if not rospy.is_shutdown():
			# Good to go, start mission
			rospy.loginfo("Starting waypoint mission / Starting Callbacks")

			# Setup first waypoint segment
			# XXX:	Another option would be to do "takeoff" and leave "waypoint_counter = 0" to
			#		begin the mission at the first waypoint after take-off
			self.send_wp(self.waypoints[0])
			self.waypoint_counter += 1

			# Setup a timer to check if our waypoint has completed at 20Hz
			self.timer = rospy.Timer(rospy.Duration(1.0/20.0), self.check_waypoint_status)
			# Callback to save "current location" such that we can perform and return from a diversion to the correct location
			self.sub_pose = rospy.Subscriber("~pose", PoseStamped, self.callback_pose)
			# Subscriber to catch "ROI" diversion commands
			self.sub_roi = rospy.Subscriber("~roi", PoseStamped, self.callback_inspect_roi)
			# Safe landing subscriber (for low battery status)
			self.sub_battery = rospy.Subscriber('/mavros/battery',BatteryState,self.callback_battery)
			
			# Published for GCS VOCAL
			self.pub_land_vocal = rospy.Publisher('vocal/land', Bool, queue_size = 10)
			self.pub_aruco_vocal = rospy.Publisher('vocal/aruco', Int32, queue_size = 10)

			# Subscriber for ArUco Marker Detection
			self.sub_aruco = rospy.Subscriber('/processed_aruco/localisation', ArucoLocalisation, self.callback_aruco_marker)

			# If shutdown is issued (eg. CTRL+C), cancel current mission before rospy is shutdown.
			rospy.on_shutdown(lambda : self.shutdown())

	def callback_battery(self,msg_in): # callback for battery percentage tracking
		self.battery_per = msg_in.percentage
		Bat = '/mavros/battery'
		#print(f"callback received topic value is:{Bat}")

	def low_battery_landing(self,timer=None):
		if self.battery_per <= 0.07 and not self.crit_bat_land_init:
			self.crit_bat_land_init = True
			print(f"Battery Percentage Critical: {self.battery_per}")
			print("Aborting Mission, Landing at current position")
			self.spar_client.cancel_goal()
			goal = FlightMotionGoal()
			goal.motion = FlightMotionGoal.MOTION_LAND
			goal.velocity_vertical = rospy.get_param("~speed", 0.2)
			# Send the land signal/goals
			rospy.loginfo("Sending landing signal...")
			self.spar_client.send_goal(goal)
			self.spar_client.wait_for_result()
			# Output feedback on the landing result
			result = self.spar_client.get_state()
			if result == GoalStatus.SUCCEEDED:
				rospy.loginfo("Landing complete!")
				self.mission_completed = True
				self.spar_client.cancel_goal() # cance goal to finish mission
				self.shutdown()
			else:
				rospy.logerr("Landing failed!")

	def callback_aruco_marker(self, msg_in):
		# Only run ArUco detection if the UAV is at the desired flight height (Reached the first waypoint, and not performing ROI tasks)
		if self.reached_wp_1 and not self.performing_roi:
			self.current_aruco_id = msg_in.aruco_id # saved the detected aruco to current
			# Only runs in the initial detection
			if self.current_aruco_id != self.previous_aruco_id:
				self.pub_aruco_vocal.publish(msg_in.aruco_id) # published the id for the GCS
				rospy.loginfo('ArUco Found!')
				# Check if the found aruco is the desired aruco
				if self.desired_aruco_id == msg_in.aruco_id:
					aruco_location = self.aruco_frame_translation([msg_in.frame_x, msg_in.frame_y]) # transform the location to usable location
					# Display the location of the uav and aruco
					rospy.loginfo(f'UAV Location at x: {self.current_location.x}, y: {self.current_location.y}')
					rospy.loginfo(f'Desired Aruco Marker {msg_in.aruco_id} Detected at x: {aruco_location[0]}, y: {aruco_location[1]}')
					self.landing_wp = [aruco_location[0], aruco_location[1], flight_height, 0] # Store the location
					self.FoundAruco = True # Flag that the desired aruco marker is found
				self.previous_aruco_id = self.current_aruco_id

	# This function will check receive the current pose of the UAV constantly
	def callback_pose(self, msg_in):
		#rospy.loginfo("Pose Callback recieved/Triggered")
		# Store the current position at all times so it can be accessed later
		self.current_location = msg_in.pose.position

	# This function will fire whenever a ROI pose message is sent
	# It is also responsible for handling the ROI "inspection task"
	def callback_inspect_roi(self, msg_in):
		rospy.loginfo("ROI Callback recieved/triggered")
		# Set our flag that we are performing the diversion
		self.performing_roi = True
		rospy.loginfo("Starting diversion to ROI...")
		# Cancel the current goal (if there is one)
		self.spar_client.cancel_goal()

		# Set the "diversion waypoint" (at yaw zero)
		dwp = [msg_in.pose.position.x, msg_in.pose.position.y, msg_in.pose.position.z + 0.5, 0.0]
		#rospy.loginfo("Diversion WP")
		#rospy.loginfo(msg_in.pose.position.x,msg_in.pose.position.y,msg_in.pose.position.z)
		# Set the "return waypoint" (at yaw zero)
		rwp = [self.current_location.x, self.current_location.y, self.current_location.z, 0.0]
		#rospy.loginfo("Return WP")
		#rospy.loginfo(self.current_location.x,self.current_location.y,self.current_location.z)

		self.send_wp(dwp)
		rospy.loginfo("Reached diversion ROI!")
		rospy.sleep(rospy.Duration(10)) # 10 sec to drop payload
		# XXX: Do something? drop payload
		rospy.loginfo("Returning to flight plan...")
		self.send_wp(rwp)

		# "waypoint_counter" represents the "next waypoint"
		# "waypoint_counter - 1" represents the "current waypoint"
		rospy.loginfo("Resuming flight plan from waypoint %i!" % (self.waypoint_counter - 1))
		self.send_wp(self.waypoints[self.waypoint_counter - 1])
		# Unset our flag that we are performing a diversion
		# to allow the waypoint timer to take back over
		self.performing_roi = False

	# This function is used to translate between the camera frame and the world location when undertaking aruco detection
	def aruco_frame_translation(self, camera_location):
		# The initial location of the UAV
		world_x = self.current_location.x
		world_y = self.current_location.y

		# Normalised position of the target within the camera frame [-1, 1] in both x- and y-directions
		# Positive values correspond to positive values in the world frame
		# The input camera location is given as the pixel position of the aruco centroid within the frame
		camera_offset_x = (208 - camera_location[0]) / 208
		camera_offset_y = (208 - camera_location[1]) / 208

		# The offset from the UAV of the target, based on the location within the camera frame
		offset_x = camera_offset_x * flight_height * tan(self.camera_FOV_x / 2) 
		offset_y = camera_offset_y * flight_height * tan(self.camera_FOV_y / 2) 

		# Add the offset to the initial location to determine the target location
		world_x += offset_x
		world_y += offset_y

		# Store the world location in a single array to be returned by the function
		world_location = [world_x, world_y]
		return world_location
	
	def send_wp(self, wp):
		# Make sure the waypoint is valid before continuing
		if not self.check_waypoint(wp):
			print("Invalid waypoint list input!, reccommend abort")

		# Build the flight goal
		goal = FlightMotionGoal()
		goal.motion = FlightMotionGoal.MOTION_GOTO
		goal.position.x = wp[0]
		goal.position.y = wp[1]
		goal.position.z = wp[2]
		goal.yaw = wp[3]
		goal.velocity_vertical = self.vel_linear
		goal.velocity_horizontal = self.vel_linear
		goal.yawrate = self.vel_yaw
		goal.wait_for_convergence = True
		goal.position_radius = self.accuracy_pos
		goal.yaw_range = self.accuracy_yaw

		# check goal status (need to do this whenever sending actions to UAV)
		self.spar_client.send_goal(goal)
		self.spar_client.wait_for_result() # wait for waypoint to be reached
		result = self.spar_client.get_state() # check waypoints are acutally reached
		if result == GoalStatus.SUCCEEDED:
			print(f"send_wp goal succeeded for waypoint: {wp}")
		else:
			print(f"send_wp goal failed for waypoint: {wp}")
			
		 # If shutdown is issued, cancel current mission before rospy is shutdown
		rospy.on_shutdown(lambda : self.spar_client.cancel_goal())
	
	def aruco_land(self):
		if not self.aruco_land_initialised:
			# cancel current goal if there is one
			self.spar_client.cancel_goal()
			# Set the current UAV location including flight height
			starting_location = [self.current_location.x, self.current_location.y, flight_height, 0]
			# Check if an ArUco marker is detected to determine landing location
			if self.FoundAruco:  # Land at ArUco marker's coordinates
				rospy.loginfo("ArUco marker found. Landing at marker location.")
				landing_location = self.landing_wp  # Coordinates of detected ArUco marker (@ current altitude)
			else:  # Land at the origin
				rospy.loginfo("No ArUco marker detected. Landing at origin.")
				landing_location = [0, 0, flight_height, 0]  # Origin coordinates
			
			# Plan the path from current location to the landing location (@ current altitude)
			self.landing_path = self.path_plan([starting_location, landing_location])
			# Send the UAV to the landing waypoints (@ current altitude)
			for landing_path in self.landing_path:
				self.send_wp(landing_path)
			# cancel previous goal set by send_wp()
			self.spar_client.cancel_goal()
			# Create the goal object for landing
			goal = FlightMotionGoal()
			goal.motion = FlightMotionGoal.MOTION_LAND
			goal.velocity_vertical = 0.25  # Set slow vertical landing velocity
			# Send the land signal/goals
			rospy.loginfo("Sending landing signal...")
			self.spar_client.send_goal(goal)
			self.spar_client.wait_for_result()

			# Output feedback on the landing result
			result = self.spar_client.get_state()
			if result == GoalStatus.SUCCEEDED:
				self.pub_land_vocal.publish(True)
				rospy.loginfo("Landing complete!")
				self.mission_completed = True
				self.spar_client.cancel_goal() # cance goal to finish mission
			else:
				rospy.logerr("Landing failed!")
			# set landing initialisation flag 
			self.aruco_land_initialised = True

		# Handle shutdown by cancelling the current mission
		rospy.on_shutdown(lambda: self.spar_client.cancel_goal())

	def path_plan(self, waypoints):
		wps = [] # initialise wps list
		# Loop through the list of waypoints
		for i in range(len(waypoints)-1):
			# Set up a path request for breadcrumb
			# breadcrumb provides a sub-path generated waypoints list such that sub-waypoints are generated between the primary waypoints, 
			# 2 primary waypoints (req.start & req.end) are sent individually, iterating through the entire waypoint list, and sub-waypoints
			# are outputted as wps. 
			req = RequestPathRequest()

			# Set start and end point
			req.start.x = waypoints[i][0]
			req.start.y = waypoints[i][1]
			req.start.z = waypoints[i][2]
			req.end.x = waypoints[i+1][0]
			req.end.y = waypoints[i+1][1]
			req.end.z = waypoints[i+1][2]
			res = self.srvc_bc(req)
			# sparse_path can optimise sub-waypoints generated by breadcrumb in-between the main waypoints
			# print to screen whether sparse_path or path was used (to observe optimisations)
			if len(res.path_sparse.poses) > 0:  # Check if sparse path is available
				rospy.loginfo("Sparse path found between waypoints %d, %d, and %d", i, i + 1, i + 2)
				for pose in res.path_sparse.poses:
					wps.append([pose.position.x, pose.position.y, pose.position.z, 0])
			elif len(res.path.poses) > 0:  # Fallback to full path if sparse is not available
				rospy.loginfo("Full path found between waypoints %d, %d, and %d", i, i + 1, i + 2)
				for pose in res.path.poses:
					wps.append([pose.position.x, pose.position.y, pose.position.z, 0])
			else:
				rospy.logerr("No valid path found for waypoints %d, %d, and %d", i, i + 1, i + 2)
		# return appended wps variable (as new waypoint list)
		print(f"breadcrumb waypoints: {len(wps)}")
		print(f"generated waypoints: {len(waypoints)}")
		display_path(wps) # publishes total planned path to rviz
		return wps

	# This function will check if a list of waypoints is in the format we expect
	def check_waypoints(self, wps):
		# Make sure waypoints are a list
		if not isinstance(wps, list):
			rospy.logwarn("Waypoints are not list")
			return False

		# Make sure we have at least one waypoint
		if len(wps) < 1:
			rospy.logwarn("Waypoints list is empty")
			return False

		# Check each of our waypoints are a list ^
		for i in range(len(wps)):
			if not self.check_waypoint(wps[i]):
				rospy.logwarn("Waypoint %i did not pass check" % (i + 1))
				return False
		# If we haven't returned false yet, then waypoints look good!
		return True

	# This function will check if a waypoint is in the format we expect
	def check_waypoint(self, wp):
		# Make sure each waypoint is a list
		if not isinstance(wp, list):
			rospy.logwarn("Waypoint is not a list of coordinates")
			return False

		# Make sure each waypoint has 4 values
		if len(wp) != 4:
			rospy.logwarn("Waypoint has an invalid length (must be X/Y/Z/Yaw)")
			return False

		# If we haven't returned false yet, then waypoint looks valid!
		return True

	# This function will make sure we shut down the node as safely as possible
	def shutdown(self):
		# Unregister anything that needs it here
		self.sub_pose.unregister()
		self.sub_roi.unregister()
		self.timer.unregister()
		self.sub_battery.unregister()
		self.spar_client.cancel_goal()
		rospy.loginfo("Guidance stopped")

	# This function will fire whenever we recieve a timer event (te) from rospy.Timer()
	# The main purpose is to check if a waypoint has been reached,
	# and if so, send out the next waypoint to continue the mission
	def check_waypoint_status(self, te):
		self.low_battery_landing()
		# If we're performing the ROI diversion, then don't do
		# anything here, as this is handled in that function
		if not (self.performing_roi or self.mission_completed):
			# if last send_wp/action succeeded run this if loop 
			if self.spar_client.get_state() == GoalStatus.SUCCEEDED:
				rospy.loginfo("Reached waypoint %i!" % (self.waypoint_counter))
				# XXX:	Another check could go here to finish the mission early
				#		if "all" inspection tasks have been completed
				#		(Add in another "if" and make the waypoint counter check
				#		 an "elif" check instead.
				#		 i.e. if complete; elif more wps; else wps finished)
				# only run this if loop if the spar_client is not waiting for a result
				if self.waypoint_counter < (len(self.waypoints)):
					# send generated waypoints to path_plan() for breadcrumb implementation
					path_plan_wps = self.path_plan([self.waypoints[self.waypoint_counter-1],self.waypoints[self.waypoint_counter]])
					# send path planned waypoints to send_wp()
					for planned_path in path_plan_wps:
						self.send_wp(planned_path)

					# Increment our waypoint counter
					self.waypoint_counter += 1
					# This will allow for target dection to be started NOT IMPLEMENTED YET
					self.reached_wp_1 = True

				else: # land() will check for aruco
					rospy.loginfo("Initiate Landing Sequence")
					# send landing
					self.aruco_land()

			elif (self.spar_client.get_state() == GoalStatus.PREEMPTED) or (self.spar_client.get_state() == GoalStatus.ABORTED) or (self.spar_client.get_state() == GoalStatus.REJECTED):
				rospy.loginfo("Mission cancelled!")
				rospy.signal_shutdown("cancelled")

def generate_waypoints(width,height,alt):
	# Set altitude & YAW
	yaw = 0.0
	waypoints = []
	# Add takeoff waypoint (over origin of map)
	waypoints.append([0, 0, alt, 0])
	# Given width and height (cannot change these)
	width = 8
	height = 5
	# Density paramater
	dn = 1.4
	# edge offsets
	x_edge_offset=0.5
	y_edge_offset=0.3

	# Calculate spacings based on the defined edge offsets
	available_x_space = width - dn * x_edge_offset
	available_y_space = height - dn * y_edge_offset
	# Calculate spacing to ensure symmetry
	x_spacing = available_x_space / (int(available_x_space) // dn)
	y_spacing = available_y_space / (int(available_y_space) // dn)
	# Adjust the grid to have the origin in the center and stay within bounds
	x_points = np.arange(-width/2 + x_edge_offset, width/2 - x_edge_offset + x_spacing, x_spacing)
	y_points = np.arange(-height/2 + y_edge_offset, height/2 - y_edge_offset + y_spacing, y_spacing)
	# Generate y_points from -2.4 to 2.25 (inverted range) "to have narrow side not close to net"
	#y_points = np.arange(-height/2 + y_edge_offset, height/2 - y_edge_offset + y_spacing, y_spacing)[::-1]

	# Traverse the area in a straight line along the x-axis (long axis)
	for x in x_points:
		for y in y_points:
			waypoints.append([x, y, alt, yaw])  # Initialize with z=0.0 and yaw=0.0
		y_points = y_points[::-1]  # Reverse y_points to keep a straight line in x direction

	# Add pre-landing waypoint (origin of map)
	#waypoints.append([0, 0, alt, 0])

	# Remove the middle waypoint if three consecutive waypoints are aligned
	def remove_middle_if_aligned(waypoints):
		new_waypoints = []
		i = 0
		while i < len(waypoints):
			if i > 0 and i < len(waypoints) - 1:
				prev_wp = waypoints[i - 1]
				curr_wp = waypoints[i]
				next_wp = waypoints[i + 1]
				
				# Check if the current waypoint is in a row (aligned on either axis)
				if (prev_wp[0] == curr_wp[0] == next_wp[0]) or (prev_wp[1] == curr_wp[1] == next_wp[1]):
					# Skip the current waypoint (remove it)
					i += 1
					continue

			new_waypoints.append(waypoints[i])
			i += 1
		return new_waypoints

	# Apply the function to remove middle waypoints
	waypoints = remove_middle_if_aligned(waypoints)

	#print(f"Waypoint List Generated: {waypoints}")
	print(f"x positions: {x_points}")
	print(f"y positions: {y_points}")
	print(f"altitude: {alt}")

	# Check all generated waypoints are within bounds (height, width & alt)
	within_bounds = True
	for wp in waypoints:
		x, y, z, _ = wp # "_" ignores YAW
		if not (-height/2 <= y <= height/2 and -width/2 <= x <= width/2 and z <= alt):
			within_bounds = False
			print(f"Waypoint {wp} is out of bounds!, all waypoints nulled")
			waypoints = 0
			break

	if within_bounds:
		print("All waypoints are within bounds.")

	return waypoints

def display_path(wps):
		rospy.loginfo("Displaying Path (from breadcrumb)")
		# Ensure the publisher is initialized
		pub_path = rospy.Publisher("/guidance/path", Path, queue_size=10, latch=True)
		# Create the Path message
		msg = Path()
		msg.header.frame_id = "/map"
		msg.header.stamp = rospy.Time.now()
		for wp in wps:
			pose = PoseStamped()
			pose.pose.position.x = wp[0]  # Access x from i
			pose.pose.position.y = wp[1]  # Access y from i
			pose.pose.position.z = wp[2]  # Access z from i
			# Set default orientation
			pose.pose.orientation.w = 1.0
			pose.pose.orientation.x = 0.0
			pose.pose.orientation.y = 0.0
			pose.pose.orientation.z = 0.0
			# Append the pose to the path
			msg.poses.append(pose)
		# Publish the path message
		pub_path.publish(msg)

def main(args):
	# Initialise ROS
	rospy.init_node('guidance')

	# Generate waypoint list using generate_waypoints(...); returns wps_generated
	waypoints = generate_waypoints(width=8,height=5,alt=flight_height)
	
	# send wps_pathplanned into Guidance "Guidance(wps_path_planned)"
	guide = Guidance(waypoints)

	# Spin!
	rospy.spin()


if __name__ == '__main__':
	try:
		main(sys.argv)
	except rospy.ROSInterruptException:
		pass

	print('')
